var documenterSearchIndex = {"docs":
[{"location":"#stdlib-styledstrings","page":"StyledStrings","title":"StyledStrings","text":"","category":"section"},{"location":"#stdlib-styledstrings-styling","page":"StyledStrings","title":"Styling","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"When working with strings, formatting and styling often appear as a secondary concern.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"note: Note\nFor instance, when printing to a terminal you might want to sprinkle ANSI escape sequences in the output, when outputting HTML styling constructs (<span style=\"...\">, etc.) serve a similar purpose, and so on. It is possible to simply insert the raw styling constructs into the string next to the content itself, but it quickly becomes apparent that this is not well suited for anything but the most basic use-cases. Not all terminals support the same ANSI codes, the styling constructs need to be painstakingly removed when calculating the width of already-styled content, and that's before you even get into handling multiple output formats.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Instead of leaving this headache to be widely experienced downstream, it is tackled head-on by the introduction of a special string type (AnnotatedString). This string type wraps any other string type and allows for formating information to be applied to regions (e.g. characters 1 through to 7 are bold and red).","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Regions of a string are styled by applying Faces to them —a structure that holds styling information— (think \"typeface\"). As a convenience, it is possible to name a face in the global faces dictionary instead of giving the Face directly.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Along with these capabilities, we also provide a convenient way for constructing AnnotatedStrings, detailed in Styled String Literals.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"julia> styled\"{yellow:hello} {blue:there}\"\n\"hello there\" # prints with colour in the REPL","category":"page"},{"location":"#Styling-via-[AnnotatedString](@ref-Base.AnnotatedString)s","page":"StyledStrings","title":"Styling via AnnotatedStrings","text":"","category":"section"},{"location":"#stdlib-styledstrings-faces","page":"StyledStrings","title":"Faces","text":"","category":"section"},{"location":"#The-Face-type","page":"StyledStrings","title":"The Face type","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"A Face specifies details of a typeface that text can be set in. It covers a set of basic attributes that generalise well across different formats, namely:","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"height\nweight\nslant\nforeground\nbackground\nunderline\nstrikethrough\ninverse\ninherit","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For details on the particular forms these attributes take, see the Face docstring, but of particular interest is inherit as it allows you to inherit attributes from other Faces.","category":"page"},{"location":"#The-global-faces-dictionary","page":"StyledStrings","title":"The global faces dictionary","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"To make referring to particular styles more convenient, there is a global Dict{Symbol, Face} that allows for Faces to be referred to simply by name. Packages can add faces to this dictionary via the addface! function, and the loaded faces can be easily customised.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"warning: Warning\nAny package registering new faces should ensure that they are prefixed by the package name, i.e. follow the format mypackage_myface. This is important for predictability, and to prevent name clashes.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"There is one set of exemptions to the package-prefix rule, the set of basic faces that are part of the default value of the faces dictionary.","category":"page"},{"location":"#stdlib-styledstrings-basic-faces","page":"StyledStrings","title":"Basic faces","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Basic faces are intended represent a general idea, that is widely applicable.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For setting some text with a certain attribute, we have the bold, light, italic, underline, strikethrough, and inverse faces.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"There are also named faces for the 16 terminal colours: black, red, green, yellow, blue, magenta, cyan, white, bright_black/grey/gray, bright_red, bright_green, bright_blue, bright_magenta, bright_cyan, and bright_white.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For shadowed text (i.e. dim but there) there is the shadow face. To indicate a selected region, there is the region face. Similarly for emphasis and highlighting the emphasis and highlight faces are defined. There is also code for code-like text.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For visually indicating the severity of messages the error, warning, success, info, note, and tip faces are defined.","category":"page"},{"location":"#stdlib-styledstrings-face-toml","page":"StyledStrings","title":"Customisation of faces (Faces.toml)","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"It is good for the name faces in the global face dictionary to be customizable. Theming and aesthetics are nice, and it is important for accessibility reasons too. A TOML file can be parsed into a list of Face specifications that are merged with the pre-existing entry in the face dictionary.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"A Face is represented in TOML like so:","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"[facename]\nattribute = \"value\"\n...\n\n[package.facename]\nattribute = \"value\"","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For example, if the shadow face is too hard to read it can be made brighter like so:","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"[shadow]\nforeground = \"white\"","category":"page"},{"location":"#Applying-faces-to-a-AnnotatedString","page":"StyledStrings","title":"Applying faces to a AnnotatedString","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"By convention, the :face attributes of a AnnotatedString hold information on the Faces that currently apply. This can be given in multiple forms, as a single Symbol naming a Faces in the global face dictionary, a Face itself, or a vector of either.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"The show(::IO, ::MIME\"text/plain\", ::AnnotatedString) and show(::IO, ::MIME\"text/html\", ::AnnotatedString) methods both look at the :face attributes and merge them all together when determining the overall styling.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"We can supply :face attributes to a AnnotatedString during construction, add them to the properties list afterwards, or use the convenient Styled String literals.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"julia> str1 = Base.AnnotatedString(\"blue text\", [(1:9, :face => :blue)])\n\"blue text\"\n\njulia> str2 = styled\"{blue:blue text}\"\n\"blue text\"\n\njulia> str1 == str2\ntrue\n\njulia> sprint(print, str1, context = :color => true)\n\"\\e[34mblue text\\e[39m\"\n\njulia> sprint(show, MIME(\"text/html\"), str1, context = :color => true)\n\"<pre><span style=\\\"color: #000080;\\\">blue text</span></pre>\"","category":"page"},{"location":"#stdlib-styledstring-literals","page":"StyledStrings","title":"Styled String Literals","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"To ease construction of AnnotatedStrings with Faces applied, the styled\"...\" styled string literal allows for the content and attributes to be easily expressed together via a custom grammar.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Within a styled\"...\" literal, curly parenthesis are considered special characters and must be escaped in normal usage (\\{, \\}). This allows them to be used to express annotations with (nestable) {annotations...:text} constructs.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"The annotations... component is a comma-separated list of three types of annotations.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Face names\nInline Face expressions (key=val,...)\nkey=value pairs","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Interpolation is possible everywhere except for inline face keys.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For more information on the grammar, see the extended help of the styled\"...\" docstring.","category":"page"},{"location":"#stdlib-styledstrings-api","page":"StyledStrings","title":"API reference","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"StyledStrings.@styled_str\nStyledStrings.styled\nStyledStrings.Face\nStyledStrings.addface!\nStyledStrings.SimpleColor\nBase.parse(::Type{StyledStrings.SimpleColor}, ::String)\nBase.tryparse(::Type{StyledStrings.SimpleColor}, ::String)\nBase.merge(::StyledStrings.Face, ::StyledStrings.Face)","category":"page"},{"location":"#StyledStrings.StyledMarkup.@styled_str","page":"StyledStrings","title":"StyledStrings.StyledMarkup.@styled_str","text":"@styled_str -> AnnotatedString\n\nConstruct a styled string. Within the string, {<specs>:<content>} structures apply the formatting to <content>, according to the list of comma-separated specifications <specs>. Each spec can either take the form of a face name, an inline face specification, or a key=value pair. The value must be wrapped by {...} should it contain any of the characters ,=:{}.\n\nString interpolation with $ functions in the same way as regular strings, except quotes need to be escaped. Faces, keys, and values can also be interpolated with $.\n\nExample\n\nstyled\"The {bold:{italic:quick} {(foreground=#cd853f):brown} fox} jumped over the {link={https://en.wikipedia.org/wiki/Laziness}:lazy} dog\"\n\nExtended help\n\nThis macro can be described by the following EBNF grammar:\n\nstyledstring = { styled | interpolated | escaped | plain } ;\n\nspecialchar = '{' | '}' | '$' | '\\\"' ;\nanychar = [\\u0-\\u1fffff] ;\nplain = { anychar - specialchar } ;\nescaped = '\\\\', specialchar ;\n\ninterpolated = '$', ? expr ? | '$(', ? expr ?, ')' ;\n\nstyled = '{', ws, annotations, ':', content, '}' ;\ncontent = { interpolated | plain | escaped | styled } ;\nannotations = annotation | annotations, ws, ',', ws, annotation ;\nannotation = face | inlineface | keyvalue ;\nws = { ' ' | '\\t' | '\\n' } ; (* whitespace *)\n\nface = facename | interpolated ;\nfacename = [A-Za-z0-9_]+ ;\n\ninlineface = '(', ws, [ faceprop ], { ws, ',', faceprop }, ws, ')' ;\nfaceprop = [a-z]+, ws, '=', ws, ( [^,)]+ | interpolated) ;\n\nkeyvalue = key, ws, '=', ws, value ;\nkey = ( [^${}=,:], [^=,:]* ) | interpolated ;\nvalue = simplevalue | curlybraced | interpolated ;\ncurlybraced = '{' { escaped | plain } '}' ;\nsimplevalue = [^${},:], [^,:]* ;\n\nThe above grammar for inlineface is simplified, as the actual implementation is a bit more sophisticated. The full behaviour is given below.\n\nfaceprop = ( 'face', ws, '=', ws, ( ? string ? | interpolated ) ) |\n           ( 'height', ws, '=', ws, ( ? number ? | interpolated ) ) |\n           ( 'weight', ws, '=', ws, ( symbol | interpolated ) ) |\n           ( 'slant', ws, '=', ws, ( symbol | interpolated ) ) |\n           ( ( 'foreground' | 'fg' | 'background' | 'bg' ),\n               ws, '=', ws, ( simplecolor | interpolated ) ) |\n           ( 'underline', ws, '=', ws, ( underline | interpolated ) ) |\n           ( 'strikethrough', ws, '=', ws, ( bool | interpolated ) ) |\n           ( 'inverse', ws, '=', ws, ( bool | interpolated ) ) |\n           ( 'inherit', ws, '=', ws, ( inherit | interpolated ) ) ;\n\nnothing = 'nothing' ;\nbool = 'true' | 'false' ;\nsymbol = [^ ,)]+ ;\nhexcolor = ('#' | '0x'), [0-9a-f]{6} ;\nsimplecolor = hexcolor | symbol | nothing ;\n\nunderline = nothing | bool | simplecolor | underlinestyled;\nunderlinestyled = '(', whitespace, ('' | nothing | simplecolor), whitespace,\n                  ',', whitespace, symbol, whitespace ')' ;\n\ninherit = ( '[', inheritval, { ',', inheritval }, ']' ) | inheritval;\ninheritval = whitespace, ':'?, symbol ;\n\n\n\n\n\n","category":"macro"},{"location":"#StyledStrings.StyledMarkup.styled","page":"StyledStrings","title":"StyledStrings.StyledMarkup.styled","text":"styled(content::AbstractString) -> AnnotatedString\n\nConstruct a styled string. Within the string, {<specs>:<content>} structures apply the formatting to <content>, according to the list of comma-separated specifications <specs>. Each spec can either take the form of a face name, an inline face specification, or a key=value pair. The value must be wrapped by {...} should it contain any of the characters ,=:{}.\n\nThis is a functional equivalent of the @styled_str macro, just without interpolation capabilities.\n\n\n\n\n\n","category":"function"},{"location":"#StyledStrings.Face","page":"StyledStrings","title":"StyledStrings.Face","text":"A Face is a collection of graphical attributes for displaying text. Faces control how text is displayed in the terminal, and possibly other places too.\n\nMost of the time, a Face will be stored in the global faces dicts as a unique association with a face name Symbol, and will be most often referred to by this name instead of the Face object itself.\n\nAttributes\n\nAll attributes can be set via the keyword constructor, and default to nothing.\n\nheight (an Int or Float64): The height in either deci-pt (when an Int), or as a factor of the base size (when a Float64).\nweight (a Symbol): One of the symbols (from faintest to densest) :thin, :extralight, :light, :semilight, :normal, :medium, :semibold, :bold, :extrabold, or :black. In terminals any weight greater than :normal is displayed as bold, and in terminals that support variable-brightness text, any weight less than :normal is displayed as faint.\nslant (a Symbol): One of the symbols :italic, :oblique, or :normal.\nforeground (a SimpleColor): The text foreground color.\nbackground (a SimpleColor): The text background color.\nunderline, the text underline, which takes one of the following forms:\na Bool: Whether the text should be underlined or not.\n\na SimpleColor: The text should be underlined with this color.\n\na Tuple{Nothing, Symbol}: The text should be underlined using the style set by the Symbol, one of :straight, :double, :curly, :dotted, or :dashed.\n\na Tuple{SimpleColor, Symbol}: The text should be underlined in the specified SimpleColor, and using the style specified by the Symbol, as before.\nstrikethrough (a Bool): Whether the text should be struck through.\ninverse (a Bool): Whether the foreground and background colors should be inverted.\ninherit (a Vector{Symbol}): Names of faces to inherit from, with earlier faces taking priority. All faces inherit from the :default face.\n\n\n\n\n\n","category":"type"},{"location":"#StyledStrings.addface!","page":"StyledStrings","title":"StyledStrings.addface!","text":"addface!(name::Symbol => default::Face)\n\nCreate a new face by the name name. So long as no face already exists by this name, default is added to both FACES.default and (a copy of) to FACES.current, with the current value returned.\n\nShould the face name already exist, nothing is returned.\n\nExamples\n\njulia> addface!(:mypkg_myface => Face(slant=:italic, underline=true))\nFace (sample)\n         slant: italic\n     underline: true\n\n\n\n\n\n","category":"function"},{"location":"#StyledStrings.SimpleColor","page":"StyledStrings","title":"StyledStrings.SimpleColor","text":"struct SimpleColor\n\nA basic representation of a color, intended for string styling purposes. It can either contain a named color (like :red), or an RGBTuple which is a NamedTuple specifying an r, g, b color with a bit-depth of 8.\n\nConstructors\n\nSimpleColor(name::Symbol)  # e.g. :red\nSimpleColor(rgb::RGBTuple) # e.g. (r=1, b=2, g=3)\nSimpleColor(r::Integer, b::Integer, b::Integer)\nSimpleColor(rgb::UInt32)   # e.g. 0x123456\n\nAlso see tryparse(SimpleColor, rgb::String).\n\n\n\n\n\n","category":"type"},{"location":"#Base.parse-Tuple{Type{StyledStrings.SimpleColor}, String}","page":"StyledStrings","title":"Base.parse","text":"parse(::Type{SimpleColor}, rgb::String)\n\nAn analogue of tryparse(SimpleColor, rgb::String) (which see), that raises an error instead of returning nothing.\n\n\n\n\n\n","category":"method"},{"location":"#Base.tryparse-Tuple{Type{StyledStrings.SimpleColor}, String}","page":"StyledStrings","title":"Base.tryparse","text":"tryparse(::Type{SimpleColor}, rgb::String)\n\nAttempt to parse rgb as a SimpleColor. If rgb starts with # and has a length of 7, it is converted into a RGBTuple-backed SimpleColor. If rgb starts with a-z, rgb is interpreted as a color name and converted to a Symbol-backed SimpleColor.\n\nOtherwise, nothing is returned.\n\nExamples\n\njulia> tryparse(SimpleColor, \"blue\")\nSimpleColor(blue)\n\njulia> tryparse(SimpleColor, \"#9558b2\")\nSimpleColor(#9558b2)\n\njulia> tryparse(SimpleColor, \"#nocolor\")\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{StyledStrings.Face, StyledStrings.Face}","page":"StyledStrings","title":"Base.merge","text":"merge(initial::Face, others::Face...)\n\nMerge the properties of the initial face and others, with later faces taking priority.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Everything documented in this page is internal and subject to breaking changes, even in minor version updates of Julia or StyledStrings.jl. If you are curious about the internals, read on, but if you want to depend on them, please consider opening a pull request or issue to discuss making them part of the public API.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"StyledStrings.ANSI_4BIT_COLORS\nStyledStrings.FACES\nStyledStrings.HTML_BASIC_COLORS\nStyledStrings.Legacy.ANSI_256_COLORS\nStyledStrings.Legacy.NAMED_COLORS\nStyledStrings.Legacy.RENAMED_COLORS\nStyledStrings.Legacy.legacy_color\nStyledStrings.Legacy.load_env_colors!\nStyledStrings.ansi_4bit_color_code\nStyledStrings.eachregion\nStyledStrings.face!\nStyledStrings.getface\nStyledStrings.loadface!\nStyledStrings.loaduserfaces!\nStyledStrings.resetfaces!\nStyledStrings.termcolor\nStyledStrings.termcolor24bit\nStyledStrings.termcolor8bit\nStyledStrings.withfaces","category":"page"},{"location":"internals/#StyledStrings.ANSI_4BIT_COLORS","page":"Internals","title":"StyledStrings.ANSI_4BIT_COLORS","text":"A mapping between ANSI named colours and indices in the standard 256-color table. The standard colors are 0-7, and high intensity colors 8-15.\n\nThe high intensity colors are prefixed by \"bright\". The \"brightblack\" color is given two aliases: \"grey\" and \"gray\".\n\n\n\n\n\n","category":"constant"},{"location":"internals/#StyledStrings.FACES","page":"Internals","title":"StyledStrings.FACES","text":"Globally named Faces.\n\ndefault gives the initial values of the faces, and current holds the active (potentially modified) set of faces. This two-set system allows for any modifications to the active faces to be undone.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#StyledStrings.HTML_BASIC_COLORS","page":"Internals","title":"StyledStrings.HTML_BASIC_COLORS","text":"A mapping between ANSI named colors and 8-bit colors for use in HTML representations.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#StyledStrings.Legacy.ANSI_256_COLORS","page":"Internals","title":"StyledStrings.Legacy.ANSI_256_COLORS","text":"A mapping from 256-color codes indicies to 8-bit colours.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#StyledStrings.Legacy.NAMED_COLORS","page":"Internals","title":"StyledStrings.Legacy.NAMED_COLORS","text":"A list of all named colors recognised, including both the old light_* and new bright_* named colors.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#StyledStrings.Legacy.RENAMED_COLORS","page":"Internals","title":"StyledStrings.Legacy.RENAMED_COLORS","text":"A mapping from old named colours to the new names, specifically from light_* to bright_*.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#StyledStrings.Legacy.legacy_color","page":"Internals","title":"StyledStrings.Legacy.legacy_color","text":"legacy_color(color::Union{String, Symbol, Int})\n\nAttempt to obtain a SimpleColor for a \"legacy\" color value color.\n\nWhen this is not possible, nothing is returned.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.Legacy.load_env_colors!","page":"Internals","title":"StyledStrings.Legacy.load_env_colors!","text":"load_env_colors!()\n\nTry to emulate the effect of the various *_color() functions of Base, by loading any specified colours as foregrounds of the relevant faces.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.ansi_4bit_color_code","page":"Internals","title":"StyledStrings.ansi_4bit_color_code","text":"ansi_4bit_color_code(color::Symbol, background::Bool=false)\n\nProvide the color code (30-37, 40-47, 90-97, 100-107) for color, as a string. When background is set the background variant will be provided, otherwise the provided code is for setting the foreground color.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.eachregion","page":"Internals","title":"StyledStrings.eachregion","text":"eachregion(s::AnnotatedString{S})\neachregion(s::SubString{AnnotatedString{S}})\n\nIdentify the contiguous substrings of s with a constant annotations, and return an iterator which provides each substring and the applicable annotations as a Tuple{SubString{S}, Vector{Pair{Symbol, Any}}}.\n\nExamples\n\njulia> collect(StyledStrings.eachregion(Base.AnnotatedString(\n           \"hey there\", [(1:3, :face => :bold), (5:9, :face => :italic)])))\n3-element Vector{Tuple{SubString{String}, Vector{Pair{Symbol, Any}}}}:\n (\"hey\", [:face => :bold])\n (\" \", [])\n (\"there\", [:face => :italic])\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.face!","page":"Internals","title":"StyledStrings.face!","text":"face!(str::Union{<:AnnotatedString, <:SubString{<:AnnotatedString}},\n      [range::UnitRange{Int},] face::Union{Symbol, Face})\n\nApply face to str, along range if specified or the whole of str.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.getface","page":"Internals","title":"StyledStrings.getface","text":"getface(faces)\n\nObtain the final merged face from faces, an iterator of Faces, face name Symbols, and lists thereof.\n\n\n\n\n\ngetface(annotations::Vector{Pair{Symbol, Any}})\n\nCombine all of the :face annotations with getfaces.\n\n\n\n\n\ngetface()\n\nObtain the default face.\n\n\n\n\n\ngetface(s::AnnotatedString, i::Integer)\n\nGet the merged Face that applies to s at index i.\n\n\n\n\n\ngetface(c::AnnotatedChar)\n\nGet the merged Face that applies to c.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.loadface!","page":"Internals","title":"StyledStrings.loadface!","text":"loadface!(name::Symbol => update::Face)\n\nMerge the face name in FACES.current with update. If the face name does not already exist in FACES.current, then it is set to update. To reset a face, update can be set to nothing.\n\nExamples\n\njulia> loadface!(:red => Face(foreground=0xff0000))\nFace (sample)\n    foreground: #ff0000\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.loaduserfaces!","page":"Internals","title":"StyledStrings.loaduserfaces!","text":"loaduserfaces!(faces::Dict{String, Any})\n\nFor each face specified in Dict, load it to FACES.current.\n\n\n\n\n\nloaduserfaces!(tomlfile::String)\n\nLoad all faces declared in the Faces.toml file tomlfile.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.resetfaces!","page":"Internals","title":"StyledStrings.resetfaces!","text":"resetfaces!()\n\nReset the current global face dictionary to the default value.\n\n\n\n\n\nresetfaces!(name::Symbol)\n\nReset the face name to its default value, which is returned.\n\nIf the face name does not exist, nothing is done and nothing returned. In the unlikely event that the face name does not have a default value, it is deleted, a warning message is printed, and nothing returned.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.termcolor","page":"Internals","title":"StyledStrings.termcolor","text":"termcolor(io::IO, color::SimpleColor, category::Char)\n\nPrint to io the SGR code to set the category's slot to color, where category is set as follows:\n\n'3' sets the foreground color\n'4' sets the background color\n'5' sets the underline color\n\nIf color is a SimpleColor{Symbol}, the value should be a a member of ANSI_4BIT_COLORS. Any other value will cause the color to be reset.\n\nIf color is a SimpleColor{RGBTuple} and get_have_truecolor() returns true, 24-bit color is used. Otherwise, an 8-bit approximation of color is used.\n\n\n\n\n\ntermcolor(io::IO, ::Nothing, category::Char)\n\nPrint to io the SGR code to reset the color for category.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.termcolor24bit","page":"Internals","title":"StyledStrings.termcolor24bit","text":"termcolor24bit(io::IO, color::RGBTuple, category::Char)\n\nPrint to io the 24-bit SGR color code to set the category8 slot to color.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.termcolor8bit","page":"Internals","title":"StyledStrings.termcolor8bit","text":"termcolor8bit(io::IO, color::RGBTuple, category::Char)\n\nPrint to io the best 8-bit SGR color code that sets the category color to be close to color.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.withfaces","page":"Internals","title":"StyledStrings.withfaces","text":"withfaces(f, kv::Pair...)\n\nExecute f with FACES.current temporarily modified by zero or more :name => val arguments kv. withfaces is generally used via the withfaces(kv...) do ... end syntax. A value of nothing can be used to temporarily unset an face (if if has been set). When withfaces returns, the original FACES.current has been restored.\n\nExamples\n\njulia> withfaces(:yellow => Face(foreground=:red), :green => :blue) do\n           println(styled\"{yellow:red} and {green:blue} mixed make {magenta:purple}\")\n       end\nred and blue mixed make purple\n\n\n\n\n\nwithfaces(f, altfaces::Dict{Symbol, Face})\n\nExecute f with FACES.current temporarily swapped out with altfaces When withfaces returns, the original FACES.current has been restored.\n\n\n\n\n\n","category":"function"}]
}
